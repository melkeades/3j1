{
    "sourceFile": "main 2612 galaxy.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1672029631941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1672029631941,
            "name": "Commit-0",
            "content": "import './style.styl'\n\nimport * as THREE from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader'\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry'\nimport * as dat from 'dat.gui'\nimport { AdditiveBlending } from 'three'\n\nconst select = (e) => document.querySelector(e)\n\n// Settings\nconst canvas = select('canvas.ca')\nlet devicePixelRatio = Math.min(window.devicePixelRatio, 2)\nconst scene = new THREE.Scene()\nlet sizes = { width: window.innerWidth, height: window.innerHeight }\n\n// Materials\nconst loadingManager = new THREE.LoadingManager()\nconst textureLoader = new THREE.TextureLoader(loadingManager).setPath('/static/textures/')\nconst particleTexture = textureLoader.load('particles/2.png')\n// MESH\nconst params = {\n  count: 10000,\n  size: 0.1,\n  radius: 5,\n  branches: 3,\n  spin: 1,\n  randomness: 2,\n  randomnessPow: 2,\n  inColor: '#ff7777',\n  outColor: '#7777ff',\n}\nconst gui = new dat.GUI({ width: 400 })\nlet galaxyGeometry = null\nlet galaxyPoints = null\nlet galaxyMaterial = null\nconst generateGalaxy = () => {\n  if (galaxyPoints !== null) {\n    galaxyGeometry.dispose()\n    galaxyMaterial.dispose()\n    scene.remove(galaxyPoints)\n  }\n  galaxyGeometry = new THREE.BufferGeometry()\n  const position = new Float32Array(params.count * 3)\n  const colors = new Float32Array(params.count * 3)\n  const colorIn = new THREE.Color(params.inColor)\n  const colorOut = new THREE.Color(params.outColor)\n\n  console.log(colorIn)\n  for (let i = 0; i < params.count * 3; i++) {\n    const i3 = i * 3\n    const radius = Math.random() * params.radius\n    const spinAgnle = radius * params.spin\n    const branchesAngle = ((i % params.branches) / params.branches) * Math.PI * 2\n    function ranPow(math) {\n      return Math.pow(math, params.randomnessPow) * (Math.random() > 0.5 ? 1 : -1)\n    }\n\n    const randomX = ranPow(Math.random())\n    const randomY = ranPow(Math.random())\n    const randomZ = ranPow(Math.random())\n    position[i3 + 0] = Math.cos(branchesAngle + spinAgnle) * radius + randomX\n    position[i3 + 1] = randomY\n    position[i3 + 2] = Math.sin(branchesAngle + spinAgnle) * radius + randomZ\n\n    const mixColor = colorIn.clone()\n    mixColor.lerp(colorOut, radius / params.radius)\n\n    colors[i3] = mixColor.r\n    colors[i3 + 1] = mixColor.g\n    colors[i3 + 2] = mixColor.b\n    if (i < 20) {\n      console.log(i, mixColor)\n    }\n  }\n  galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(position, 3))\n  galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))\n  galaxyMaterial = new THREE.PointsMaterial({\n    color: 0xffffff,\n    size: params.size,\n    sizeAttenuation: true,\n    transparent: true,\n    alphaMap: particleTexture,\n    depthWrite: false,\n    blending: AdditiveBlending,\n    vertexColors: true,\n  })\n  galaxyPoints = new THREE.Points(galaxyGeometry, galaxyMaterial)\n  scene.add(galaxyPoints)\n}\ngenerateGalaxy()\ngui.add(params, 'count').min(10).max(100000).step(10).onFinishChange(generateGalaxy)\ngui.add(params, 'size').min(0.001).max(1).step(0.001).onFinishChange(generateGalaxy)\ngui.add(params, 'radius').min(0.001).max(20).step(0.001).onFinishChange(generateGalaxy)\ngui.add(params, 'branches').min(2).max(20).step(1).onFinishChange(generateGalaxy)\ngui.add(params, 'spin').min(-5).max(5).step(0.001).onFinishChange(generateGalaxy)\ngui.add(params, 'randomness').min(0).max(2).step(0.001).onFinishChange(generateGalaxy)\ngui.add(params, 'randomnessPow').min(1).max(10).step(0.001).onFinishChange(generateGalaxy)\ngui.addColor(params, 'inColor').onFinishChange(generateGalaxy)\ngui.addColor(params, 'outColor').onFinishChange(generateGalaxy)\n\n// const g1 = generateGalaxy()\n// scene.add(g1)\n// Light\n\n// Camera\nconst camera = new THREE.PerspectiveCamera(45, sizes.width / sizes.height, 0.1, 200)\ncamera.position.z = 4\ncamera.position.y = 1\ncamera.position.x = 1\nscene.add(camera)\n\n// Renderer\nconst renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas })\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.setPixelRatio(devicePixelRatio)\n// Controls\n// gui.hide()\nconst controls = new OrbitControls(camera, canvas)\ncontrols.enableDamping = true\n\n// Updated\nconst tick = () => {\n  controls.update()\n  requestAnimationFrame(tick)\n  renderer.render(scene, camera)\n}\n\ntick()\n\nwindow.addEventListener('resize', () => {\n  const updatedPR = Math.min(window.devicePixelRatio, 2)\n  if (devicePixelRatio != updatedPR) {\n    devicePixelRatio = updatedPR\n    renderer.setPixelRatio(devicePixelRatio)\n  }\n  sizes = { width: window.innerWidth, height: window.innerHeight }\n  camera.aspect = sizes.width / sizes.height\n  camera.updateProjectionMatrix()\n  renderer.setSize(sizes.width, sizes.height)\n})\n"
        }
    ]
}